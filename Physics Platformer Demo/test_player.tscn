[gd_scene load_steps=8 format=3 uid="uid://b76cxogw2yqyl"]

[ext_resource type="PackedScene" uid="uid://c1et41fjvsa3x" path="res://projectile.tscn" id="1_if3pt"]
[ext_resource type="PackedScene" uid="uid://lhag0gi8nvwh" path="res://grapple_point_indicator.tscn" id="2_vwc77"]

[sub_resource type="GDScript" id="GDScript_m2cwo"]
resource_local_to_scene = true
script/source = "extends CharacterBody3D

# Constants
const MOVE_SPEED = 7.0
const JUMP_FORCE = 12.0
const GRAVITY = 20.0
const MAX_FALL_SPEED = 30.0
const DASH_FORCE = 10.0
const DASH_DURATION = 0.2
const GRAPPLE_DISTANCE = 10.0
const GRAPPLE_SPEED = 10.0
const GRAPPLE_PULL_SPEED = 5.0
const GRAPPLE_SWING_FORCE = 10.0
const MAX_GRAPPLE_LENGTH = 15.0  # Maximum grapple line length
const COYOTE_TIME = 0.1
const JUMP_BUFFER_TIME = 0.1
const RAYCAST_COUNT = 32
const RAYCAST_ARC_ANGLE = PI
const PREDICTOR_SHOW_DISTANCE = 20.0
const MOUSE_SNAP_ANGLE = PI / 16

# Node references
@onready var grapple_line: MeshInstance3D = $GrappleLine
@onready var cursor_predictor: MeshInstance3D = $CursorPredictor
@onready var character_mesh: MeshInstance3D = $CharacterMesh
@onready var ball_mesh: MeshInstance3D = $BallMesh

# Variables
var y_velo = 0.0
var facing_right = true
var is_jumping = false
var is_dashing = false
var dash_timer = 0.0
var dash_direction = Vector2.ZERO
var hook_pos = Vector3.ZERO
var hooked = false
var grapple_direction = Vector3.ZERO
var jump_count = 0
var coyote_timer = 0.0
var jump_buffer_timer = 0.0
var is_ball_state = false
var raycasts = []

func _ready():
	setup_grapple_line()
	setup_cursor_predictor()
	setup_raycasts()
	ball_mesh.visible = false
	cursor_predictor.visible = true

func _process(delta):
	update_raycast_positions()
	update_grapple_line()
	update_cursor_predictor()

func _physics_process(delta):
	if not is_ball_state:
		handle_movement(delta)
	else:
		handle_ball_movement(delta)
	
	handle_grapple(delta)
	update_raycast_positions()

func setup_grapple_line():
	var material = StandardMaterial3D.new()
	material.albedo_color = Color.RED
	material.flags_unshaded = true
	grapple_line.material_override = material
	grapple_line.mesh = ImmediateMesh.new()

func setup_cursor_predictor():
	var material = StandardMaterial3D.new()
	material.albedo_color = Color(1, 1, 1, 0.5)
	material.flags_unshaded = true
	cursor_predictor.material_override = material
	
	var mesh = ImmediateMesh.new()
	cursor_predictor.mesh = mesh
	
	cursor_predictor.visible = true

func setup_raycasts():
	for i in range(RAYCAST_COUNT):
		var raycast = RayCast3D.new()
		raycast.enabled = true
		raycast.collision_mask = 1
		raycast.target_position = Vector3(GRAPPLE_DISTANCE, 0, 0)
		raycast.visible = false
		add_child(raycast)
		raycasts.append(raycast)


func update_cursor_predictor():
	var immediate_mesh = cursor_predictor.mesh as ImmediateMesh
	immediate_mesh.clear_surfaces()
	
	var mouse_pos = get_viewport().get_mouse_position()
	var camera = get_viewport().get_camera_3d()
	var from = global_transform.origin
	var to = camera.project_position(mouse_pos, PREDICTOR_SHOW_DISTANCE)
	var direction = (to - from).normalized()
	
	var end_point = from + direction * GRAPPLE_DISTANCE
	var space_state = get_world_3d().direct_space_state
	var query = PhysicsRayQueryParameters3D.new()
	query.from = from
	query.to = end_point
	
	var result = space_state.intersect_ray(query)
	
	if result:
		end_point = result.position
	
	immediate_mesh.surface_begin(Mesh.PRIMITIVE_LINES)
	immediate_mesh.surface_add_vertex(from - global_transform.origin)
	immediate_mesh.surface_add_vertex(end_point - global_transform.origin)
	immediate_mesh.surface_end()
	cursor_predictor.visible = true

func update_raycast_positions():
	var character_height = 2.0
	var character_center = global_transform.origin + Vector3(0, character_height / 2, 0)
	
	for i in range(RAYCAST_COUNT):
		var angle = PI - (i / (RAYCAST_COUNT - 1.0)) * RAYCAST_ARC_ANGLE
		var direction = Vector2(cos(angle), sin(angle))
		raycasts[i].global_transform.origin = character_center
		raycasts[i].target_position = Vector3(direction.x, direction.y, 0) * GRAPPLE_DISTANCE
		raycasts[i].force_raycast_update()

func handle_movement(delta):
	var move_dir = Input.get_axis(\"move_left\", \"move_right\")
	
	if not hooked:
		velocity.x = move_dir * MOVE_SPEED * (1.5 if move_dir != 0 else 1.0)
		velocity.x = lerp(velocity.x, 0.0, 0.1)
	
	update_facing_direction()
	
	if is_on_floor():
		coyote_timer = COYOTE_TIME
		reset_jump()
	else:
		coyote_timer -= delta
		velocity.x += move_dir * MOVE_SPEED * 0.1
		apply_gravity(delta)
		handle_double_jump()
	
	if Input.is_action_just_pressed(\"jump\"):
		jump_buffer_timer = JUMP_BUFFER_TIME
	else:
		jump_buffer_timer -= delta
	
	if coyote_timer > 0 and jump_buffer_timer > 0:
		jump()
		jump_buffer_timer = 0
	
	velocity.y = y_velo
	velocity.z = 0
	move_and_slide()

func handle_ball_movement(delta):
	var move_dir = Input.get_axis(\"move_left\", \"move_right\")
	velocity.x = move_dir * MOVE_SPEED * 1.5
	
	apply_gravity(delta)
	
	if is_on_floor() and Input.is_action_just_pressed(\"jump\"):
		jump()
	
	velocity.z = 0
	move_and_slide()
	
	if dash_timer > 0:
		dash_timer -= delta
		if dash_timer <= 0:
			exit_ball_state()

func update_facing_direction():
	facing_right = get_viewport().get_mouse_position().x > get_viewport().size.x / 2

func reset_jump():
	y_velo = -0.1
	is_jumping = false
	jump_count = 0

func jump():
	y_velo = JUMP_FORCE
	is_jumping = true
	jump_count += 1

func apply_gravity(delta):
	y_velo = max(y_velo - GRAVITY * delta, -MAX_FALL_SPEED)

func handle_double_jump():
	if Input.is_action_just_pressed(\"jump\") and jump_count < 2:
		jump()

func enter_ball_state():
	is_ball_state = true
	character_mesh.visible = false
	ball_mesh.visible = true
	dash_timer = DASH_DURATION
	velocity = Vector3(dash_direction.x, dash_direction.y, 0) * DASH_FORCE

func exit_ball_state():
	is_ball_state = false
	character_mesh.visible = true
	ball_mesh.visible = false

func handle_grapple(delta):
	if Input.is_action_just_pressed(\"grapple\") and not hooked:
		shoot_grapple()
	
	if hooked:
		grapple_movement(delta)
		if Input.is_action_just_released(\"grapple\"):
			detach_grapple()

func shoot_grapple():
	var mouse_pos = get_viewport().get_mouse_position()
	var camera = get_viewport().get_camera_3d()
	var from = global_transform.origin + Vector3(0, 1, 0)
	var to = camera.project_position(mouse_pos, GRAPPLE_DISTANCE)
	var direction = (to - from).normalized()
	
	var end_point = from + direction * GRAPPLE_DISTANCE
	var space_state = get_world_3d().direct_space_state
	var query = PhysicsRayQueryParameters3D.new()
	query.from = Vector3(from.x, from.y, 0.5)  # Set z-axis to 0.5
	query.to = Vector3(end_point.x, end_point.y, 0.5)  # Set z-axis to 0.5
	
	var result = space_state.intersect_ray(query)
	
	if result:
		print(\"is hooked\")
		hook_pos = result.position
		hooked = true
		velocity = Vector3.ZERO

func grapple_movement(delta):
	var hook_direction = (hook_pos - global_transform.origin).normalized()
	var distance_to_hook = global_transform.origin.distance_to(hook_pos)

	# Calculate the swing direction based on player input
	var swing_direction = Vector3(Input.get_axis(\"move_left\", \"move_right\"), 0, 0)
	
	# Calculate the swing force based on the swing direction and hook direction
	var swing_force = swing_direction.cross(hook_direction) * GRAPPLE_SWING_FORCE
	
	# Calculate the pull force based on the move_up input
	var pull_force = Vector3.ZERO
	if Input.is_action_pressed(\"move_up\"):
		pull_force = hook_direction * GRAPPLE_PULL_SPEED
	
	# Calculate the total force by combining the swing force, pull force, and gravity
	var total_force = swing_force + pull_force - Vector3.UP * GRAVITY
	
	# Update the velocity based on the total force
	velocity += total_force * delta
	
	# Limit the velocity to prevent excessive speed
	var max_velocity = 20.0
	if velocity.length() > max_velocity:
		velocity = velocity.normalized() * max_velocity
	
	# Update the character's position based on the velocity
	global_transform.origin += velocity * delta
	
	# Limit the character's position to the maximum grapple range
	if distance_to_hook > MAX_GRAPPLE_LENGTH:
		global_transform.origin = hook_pos + (global_transform.origin - hook_pos).normalized() * MAX_GRAPPLE_LENGTH
	
	global_transform.origin.z = 0  # Ensure z-axis remains at 0

func update_grapple_line():
	var immediate_mesh = grapple_line.mesh as ImmediateMesh
	immediate_mesh.clear_surfaces()
	if hooked:
		immediate_mesh.surface_begin(Mesh.PRIMITIVE_LINES)
		immediate_mesh.surface_add_vertex(Vector3.ZERO)
		immediate_mesh.surface_add_vertex(hook_pos - global_transform.origin)
		immediate_mesh.surface_end()
		grapple_line.visible = true
	else:
		grapple_line.visible = false

func detach_grapple():
	hooked = false
	velocity = velocity.normalized() * GRAPPLE_SWING_FORCE * 0.5  # Reduce the velocity when detaching
	
func find_closest_raycast(direction):
	var closest_raycast = null
	var smallest_angle = INF
	for raycast in raycasts:
		var raycast_direction = raycast.target_position.normalized()
		var angle = raycast_direction.angle_to(direction)
		if angle < smallest_angle and angle < MOUSE_SNAP_ANGLE:
			smallest_angle = angle
			closest_raycast = raycast
	return closest_raycast

 

"

[sub_resource type="CapsuleShape3D" id="CapsuleShape3D_rvl8c"]

[sub_resource type="CapsuleMesh" id="CapsuleMesh_qthqe"]

[sub_resource type="CylinderMesh" id="CylinderMesh_6j4s6"]

[sub_resource type="SphereMesh" id="SphereMesh_tairy"]

[node name="test_player" type="CharacterBody3D"]
axis_lock_linear_z = true
script = SubResource("GDScript_m2cwo")

[node name="CollisionShape3D" type="CollisionShape3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1.00934, 0)
shape = SubResource("CapsuleShape3D_rvl8c")

[node name="CharacterMesh" type="MeshInstance3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1.00564, 0)
mesh = SubResource("CapsuleMesh_qthqe")

[node name="Camera3D" type="Camera3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 2.23472, 9.65786)

[node name="Projectile" parent="." instance=ExtResource("1_if3pt")]
visible = false

[node name="MeshInstance3D" parent="Projectile" index="1"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 1.34372, 1.48517, 0)

[node name="grapple_point_indicator" parent="." instance=ExtResource("2_vwc77")]

[node name="GrappleLine" type="MeshInstance3D" parent="."]
mesh = SubResource("CylinderMesh_6j4s6")

[node name="CursorPredictor" type="MeshInstance3D" parent="."]
mesh = SubResource("SphereMesh_tairy")

[node name="BallMesh" type="MeshInstance3D" parent="."]

[editable path="Projectile"]
