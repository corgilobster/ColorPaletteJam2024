[gd_scene load_steps=5 format=3 uid="uid://b76cxogw2yqyl"]

[ext_resource type="PackedScene" uid="uid://c1et41fjvsa3x" path="res://projectile.tscn" id="1_if3pt"]

[sub_resource type="GDScript" id="GDScript_m2cwo"]
resource_local_to_scene = true
script/source = "extends CharacterBody3D

var speed = 450
var gravHook = 100
const MOVE_SPEED = 7
const JUMP_FORCE = 8.5
const GRAVITY = 20
const MAX_FALL_SPEED = 30
const DASH_FORCE = 10
const DASH_DURATION = 0.2
const GRAPPLE_SPEED = 20
const SWING_RADIUS = 5.0
const SWING_SPEED = 2.0
var closest_raycast = null
var should_grapple = false

var y_velo = 0
var facing_right = true
var is_jumping = false
var is_dashing = false
var dash_timer = 0
var dash_direction = Vector3.ZERO
var custom_velocity = Vector3()
var hook_pos = Vector3()
var hooked = false
var grapple_direction = Vector3()
var grapple_timer = 0
var grapple_duration = 1.0
var swing_angle = 0.0

var line_mesh: ImmediateMesh
var line_material: StandardMaterial3D

var projectile_scene = preload(\"res://projectile.tscn\")

func _ready():
	# Create the line mesh and material
	line_mesh = ImmediateMesh.new()
	line_material = StandardMaterial3D.new()
	line_material.vertex_color_use_as_albedo = true

	# Add the line mesh to the scene
	var line_mesh_instance = MeshInstance3D.new()
	line_mesh_instance.mesh = line_mesh
	line_mesh_instance.material_override = line_material
	add_child(line_mesh_instance)

func gravity():
	custom_velocity.y += gravHook
	custom_velocity.x += gravHook

func _process(delta):
	if hooked:
		# Clear the line mesh
		line_mesh.clear_surfaces()

		# Begin drawing the line
		line_mesh.surface_begin(Mesh.PRIMITIVE_LINES)

		# Add the start and end points of the line
		var start_pos = global_transform.origin
		var end_pos = hook_pos
		line_mesh.surface_add_vertex(start_pos)
		line_mesh.surface_add_vertex(end_pos)

		# Set the line color
		line_mesh.surface_set_color(Color.BLACK)
		line_mesh.surface_set_color(Color.BLACK)

		# End drawing the line
		line_mesh.surface_end()
	else:
		# Clear the line mesh when not hooked
		line_mesh.clear_surfaces()

func _physics_process(delta):
	gravity()
	hook()
	grapple_movement(delta)  # Call grapple_movement function

	var move_dir = Input.get_axis(\"move_left\", \"move_right\")
	if not is_dashing:
		custom_velocity.x = move_dir * MOVE_SPEED

	# Determine facing direction based on mouse position
	var mouse_position = get_viewport().get_mouse_position()
	var screen_center_x = get_viewport().size.x / 2
	facing_right = mouse_position.x > screen_center_x

	if is_on_floor():
		y_velo = -0.1
		is_jumping = false
		if Input.is_action_just_pressed(\"jump\"):
			y_velo = JUMP_FORCE
			is_jumping = true
	else:
		y_velo -= GRAVITY * delta
		y_velo = max(y_velo, -MAX_FALL_SPEED)

	if Input.is_action_just_pressed(\"dash\") and not is_dashing:
		dash()
		move_and_slide()

	if is_dashing:
		dash_timer += delta
		if dash_timer >= DASH_DURATION:
			print(\"dash is false\")
			is_dashing = false
			dash_timer = 0

	custom_velocity.y = y_velo

	velocity = custom_velocity
	move_and_slide()

func dash():
	is_dashing = true
	dash_direction = 1 if facing_right else -1
	custom_velocity = Vector3(DASH_FORCE * dash_direction, 0, 0)
	print(\"Dashing \", \"right\" if facing_right else \"left\")
	print(\"Dash force: \", DASH_FORCE * dash_direction)

func _on_projectile_collided(collision):
	var collider = collision.get_collider()
	if collider != self:
		hook_pos = collision.get_position()
		var direction = (hook_pos - global_position).normalized()
		custom_velocity = direction * GRAPPLE_SPEED
		hooked = true
		print(\"hooked is true\")
		print(\"Projectile collided at \", hook_pos)

func hook():
	if Input.is_action_just_pressed(\"grapple\") and not hooked:
		closest_raycast = null  # Initialize closest_raycast to null
		var grapplehook = get_node(\"Grapplehook\")
		var camera = get_viewport().get_camera_3d()
		var mouse_position = get_viewport().get_mouse_position()

		var closest_distance = INF

		for raycast in grapplehook.get_children():
			if raycast is RayCast3D:
				var screen_pos = camera.unproject_position(raycast.global_transform.origin)
				var distance = screen_pos.distance_to(mouse_position)

				# Check if the raycast is on the allowed side based on the mouse position
				var is_allowed_side = false
				if facing_right and raycast.name in [\"GrappleRayCast90 right\", \"GrappleRaycast80right\", \"GrappleRaycast70 right\", \"GrappleRaycast60right\"]:
					is_allowed_side = true
				elif not facing_right and raycast.name in [\"grappleRayCast90 left\", \"GrappleRaycast4\", \"GrappleRaycast7\", \"GrappleRaycast8\"]:
					is_allowed_side = true

				if is_allowed_side and distance < closest_distance and raycast.is_colliding():
					closest_raycast = raycast
					closest_distance = distance

		if closest_raycast:
			print(\"Projectile traveling on raycast: \", closest_raycast.name)

			# Instantiate a new projectile instance
			var projectile = projectile_scene.instantiate()

			# Set the projectile's position to the raycast's origin
			projectile.global_position = closest_raycast.global_transform.origin

			# Calculate the direction from the raycast's origin to the collision point
			var collision_point = closest_raycast.get_collision_point()
			var direction = (collision_point - closest_raycast.global_transform.origin).normalized()

			# Set the projectile's linear velocity to the calculated direction multiplied by the projectile's speed
			projectile.linear_velocity = direction * projectile.speed

			# Connect the projectile's collision signal to the grapple function
			projectile.connect(\"collided\", Callable(self, \"_on_projectile_collided\"))

			# Add the projectile as a child of the scene
			get_tree().current_scene.add_child(projectile)
	elif Input.is_action_just_released(\"grapple\") and hooked:
		hooked = false
		set_physics_process(true)  # Enable regular physics processing

func grapple_movement(delta):
	if hooked:
		var direction = (hook_pos - global_position).normalized()
		custom_velocity = direction * GRAPPLE_SPEED
		
		# Move the character towards the grapple position
		global_position += custom_velocity * delta
		
		# Check if the character has reached the grapple position
		if global_position.distance_to(hook_pos) < 0.1:
			hooked = false
			print(\"Reached grapple position\")
			set_physics_process(true)  # Enable regular physics processing
	else:
		hooked = false
"

[sub_resource type="CapsuleShape3D" id="CapsuleShape3D_rvl8c"]

[sub_resource type="CapsuleMesh" id="CapsuleMesh_qthqe"]

[node name="test_player" type="CharacterBody3D"]
axis_lock_linear_z = true
script = SubResource("GDScript_m2cwo")

[node name="CollisionShape3D" type="CollisionShape3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1.00934, 0)
shape = SubResource("CapsuleShape3D_rvl8c")

[node name="MeshInstance3D" type="MeshInstance3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1.00564, 0)
mesh = SubResource("CapsuleMesh_qthqe")

[node name="Camera3D" type="Camera3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 2.23472, 9.65786)

[node name="Grapplehook" type="RayCast3D" parent="."]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0)
enabled = false
target_position = Vector3(0, 5, 0)

[node name="GrappleRayCast90 right" type="RayCast3D" parent="Grapplehook"]
transform = Transform3D(-4.37114e-08, 1, 0, -1, -4.37114e-08, 0, 0, 0, 1, 1, 0.25, 0)
target_position = Vector3(0, 12, 0)

[node name="GrappleRaycast80right" type="RayCast3D" parent="Grapplehook"]
transform = Transform3D(0.173648, 0.984808, 0, -0.984808, 0.173648, 0, 0, 0, 1, 1, 0.5, 0)
target_position = Vector3(0, 12, 0)

[node name="GrappleRaycast70 right" type="RayCast3D" parent="Grapplehook"]
transform = Transform3D(0.34202, 0.939693, 0, -0.939693, 0.34202, 0, 0, 0, 1, 1, 0.75, 0)
target_position = Vector3(0, 12, 0)

[node name="GrappleRaycast60right" type="RayCast3D" parent="Grapplehook"]
transform = Transform3D(0.5, 0.866025, 0, -0.866025, 0.5, 0, 0, 0, 1, 1, 1, 0)
target_position = Vector3(0, 12, 0)

[node name="GrappleRaycast50right2" type="RayCast3D" parent="Grapplehook"]
transform = Transform3D(0.642787, 0.766044, 0, -0.766044, 0.642787, 0, 0, 0, 1, 1, 1.25, 0)
target_position = Vector3(0, 12, 0)

[node name="grappleRayCast90 left" type="RayCast3D" parent="Grapplehook"]
transform = Transform3D(-4.37114e-08, -1, 0, 1, -4.37114e-08, 0, 0, 0, 1, -1, 0.25, 0)
target_position = Vector3(0, 12, 0)

[node name="GrappleRaycast4" type="RayCast3D" parent="Grapplehook"]
transform = Transform3D(0.173648, -0.984808, 0, 0.984808, 0.173648, 0, 0, 0, 1, -1, 0.5, 0)
target_position = Vector3(0, 12, 0)

[node name="GrappleRaycast7" type="RayCast3D" parent="Grapplehook"]
transform = Transform3D(0.34202, -0.939693, 0, 0.939693, 0.34202, 0, 0, 0, 1, -1, 0.75, 0)
target_position = Vector3(0, 12, 0)

[node name="GrappleRaycast8" type="RayCast3D" parent="Grapplehook"]
transform = Transform3D(0.5, -0.866025, 0, 0.866025, 0.5, 0, 0, 0, 1, -1, 1, 0)
target_position = Vector3(0, 12, 0)

[node name="GrappleRaycast9" type="RayCast3D" parent="Grapplehook"]
transform = Transform3D(0.499999, -0.866024, 0, 0.866024, 0.499999, 0, 0, 0, 1, -1, 1, 0)
target_position = Vector3(0, 12, 0)

[node name="Projectile" parent="." instance=ExtResource("1_if3pt")]

[node name="MeshInstance3D" parent="Projectile" index="1"]
transform = Transform3D(1, 0, 0, 0, 1, 0, 0, 0, 1, 1.34372, 1.48517, 0)

[editable path="Projectile"]
